#import "@docs/bmstu:1.0.0":*
#show: student_work.with(
  caf_name: "Компьютерные системы и сети",
  faculty_name: "Информатика и системы управления",
  work_type: "лабораторной работе",
  work_num: "4",
  discipline_name: "Машинно-зависимые языки и основы компиляции",
  theme: "Обработка массивов и матриц",
  author: (group: "ИУ6-42Б", nwa: "А. П. Плютто"),
  adviser: (nwa: "Я. С. Петрова"),
  city: "Москва",
  table_of_contents: true,
)

= Ввод массива чисел

Перепишем ввод чисел: в общую библеотеку добавим процедуру ```asm getmas```, которая будет принимать на вход число чисел, которые будут записаны через пробел и сохранять их в отдельном буфере. 

#img(image("getmas.svg", width: 40%), [Схема алгоритва для ввода массива])


Тут уже берется четкое количество байт, необходимых для сохранения чисел, поэтому отсчитывать цифры числа нам больше нет необходимости. Так же, как уже говорилось в лабораторной 2 разделителями теперь будут являться пробелы, а не переносы строки. В цикле по обработке чисел я это изменил. Это все изменения, которые я произвел с процедурой ```stoi```. 

А теперь подробнее разберем саму процедуру ввода массива чисел. Единственное, что в ней по логике должно отличаться от процедуры ```asm geti``` -- это ввод вместо одного числа -- `n`. 

Будем реализовывать это через цикл, запросив `n` в регистр ```asm esi```. Остальные значения будем запрашивать в тех же регистрах, что и в процедуре ```asm geti```.

Для начала перед циклом выведем приглашение на ввод (в данной лабораторной это будут номер строк). После прочитаем ввод польщователя и подготовим некоторое смещение: из-за того что числа 4-ех байтовые, все вместе они займут $4n$ байт. 

Запишем это значение в ```asm edi```. В ```asm ecx``` будет храниться общее смещение, добавим к ```asm ecx``` ```asm edi```, таким образом получим смещение в памяти, указывающее на конечный байт. 

Теперь, вычитая ```asm edi``` из ```asm ecx```, мы сможем получать адрес первого элемента, а уменьшая ```asm edi``` на 4 за каждую итерацию цикла получим счетчик для цикла.

#let input = parserasm(read("input.asm"))
#code(funcstr(input, "getmas:"), "asm", [Процедура ```asm getmas```])

Каждую итерацию цикла будем вызывать ```asm stoi``` для обработки следующего числа. Так как ```asm stoi``` возвращает адрес, за текущим числом в тот же регистр, из которого читает адрес текущего числа, то адреса менять не придется. 

После выполнения ```asm stoi``` заносим результат выполнения в новый буфер для уже целочисленных данных, после чего выполняем проверку на выход, выходим если ```asm edi = 0```, иначе идем на следующую итерацию цикла.

#code(funcstr(input, "getmasl:"), "asm", [Цикл для чтения элементов])

В выходе освобождаем весь использованный стек, загружая в регистры начальные их значения и выходим.

#code(funcstr(input, "getmase:"), "asm", [Цикл для чтения элементов])

= Выполнение лабораторной работы

== Цель

Изучение приемов моделирования обработки массивов и матриц в языке ассемблера.

== Задание

Дана матрица $6 times 4$. Определить строку с максимальной суммой положительных элементов. Организовать ввод матрицы и вывод результатов.

== Выполнение

=== Алгоритм выполнения

Алгоритм тут простой: нам нет необходимости запрашивать все 4 строки у пользователя сразу, а потом обрабатывать -- вместо этого будем запрашивать у пользователя 1 строку, находить сумму положительных элементов, и если эта сумма больше сохраненной суммы, изменять сохраненную сумму на новую и сохранять номер строки (изначально сохраненная сумма равна 0 -- наименьшая возможная сумма положительных чисел), после чего проделываем весь цикл еще 3 раза. В результате не затрачивая памяти на хранение всех строк мы получаем готовый ответ, который выводим, используя библеотеку вывода из 2-ой лабораторной работы.



=== Работа с данными

#let lab4 = parserasm(read("lab4.asm"))
#code(funcstr(lab4, "section .data")+funcstr(lab4, "section .bss"), "asm", [Выделяем и инициализируем необходимые данные])

Метки ```asm max``` и ```asm maxi``` будут смещениями для адресов, хранящих наибольшую сумму и индекс строки с этой суммой соответственно. Метки ```asm iarr```, ```asm iarrn```, ```asm ot1```, ```asm ot2``` будут смещениями для адресов, хранящих строки для вывода пользователю, метки с такими же названиями с `l` в конце хранят количество букв. ```asm iarrn``` представляет особый интерес -- тут я записал массив строк по 3 буквы, для обозначения номера строки в память, смещением которой является одна метка, потом будем прибавлять к этой метке 3 и получать обрезанную строку с номером необходимой строки. ```asm arro``` -- место для массива чисел -- по 4 байта на 6 чисел. ```asm arri``` -- буфер, который будем использовать для ввода-вывода, я взял его побольше, но если знать максимальное количество символов, которые введет пользовалель за одну строку, его можно уменьшить. 

=== Подсчет суммы неотрицательных элементов

Сам алгоритм обработки массива для удобства выделим в отдельную процедуру, где в цикле пройдем по каждому элементу и сложим друг с другом все неотрицательные элементы.


#img(image("calcsum.svg", width: 40%), [Схема алгоритма для обработки массива])

#code(funcstr(lab4, "calcsum:"), "asm", [Процедура ```asm calcsum```])

Тут воспользуемся той же хитростью, что и при вводе -- прибавим к отдельному регистру, содеждащему смещение (тут ```asm eax```) $4n$ байта (тут ```asm ebx```) и получим счетчик, вычитая 4 из ```asm ebx```, и текущее смещение, вычитая из ```asm eax``` ```asm ebx```.

В цикле будет ветвление, поэтому для него потребуется несколько меток.

#code(funcstr(lab4, "calcsuml:"), "asm", [Процедура ```asm calcsum```: цикл \#1])

Переносим текущее число в ```asm edx``` и организуем ветвление: если перенесенное число больше нуля идем на метку ```asm calcsumlsum```.

#code(funcstr(lab4, "calcsumlsum:"), "asm", [Процедура ```asm calcsum```: цикл \#2])

Где добавляем число к получившемуся ответу и переходим к завершению итерации цикла (иначе -- сразу переходим к завершению итерации).

#code(funcstr(lab4, "calcsumle:"), "asm", [Процедура ```asm calcsum```: цикл \#3])

В конце итерации уменьшаем счетчик на 4 и проверяем условие выхода.

По завершению цикла переходим к завершению процедуры. В ней мы как обычно возвращаем все регистры и выходим из процедуры.

#code(funcstr(lab4, "calcsume:"), "asm", [Процедура ```asm calcsum```: конец])

#pagebreak()
=== Основная программа

#img(image("_start.svg", width: 40%), [Схема алгоритма для основной программы])

После описания процедуры для подсчета суммы положительных чисел в массиве перейдем к описанию основной программы, которая будет запрашивать данные, получать сумму, сравнивать сумму с наибольшей и выводить результаты.

#code(funcstr(lab4, "_start:") + funcstr(lab4, "getarr:"), "asm", [Получаем матрицу])

Для получения матрицы необходимо в цикле вызвать 4 раза получение массива и на той же итерации этот массив обработать -- пока он не затерся. Для этого на этой метке вызываем ```asm getmas```, а после того, как он отработает вызываем ```asm calcsum```. ```asm calcsum``` только возвращает результат, но ни с чем не сравнивает, поэтому сравниваем результат с текущей максимальной суммой, если он больше переходим к ```asm ecxmovmax```.

#code(funcstr(lab4, "ecxmovmax:"), "asm", [Получаем матрицу])

Тут мы запоминаем его наибольший резутьтат и номер строки, после чего программа переходит к концу получения строки матрицы -- ```asm getarre```.

#code(funcstr(lab4, "getarre:"), "asm", [Завершаем обработку строки матрицы])

В завершении увеличиваем счетчик строк и проыеряем не равен ли он 4. Если не равен, по берем следующую строку, переходя к метке ```asm getarr```, если равен переходим к завершению программы.

До разбора завершения программы хочу отметить приглашение пользователя к вводу: для этого мы использовали метку ```asm iarrn``` -- переместили ее смещение в запрашиваемый ```asm getmas``` регистр. После чего умножили 3 на счетчик текущей строки и прибавили к регистру, таким образом теперь смещение стоит на `#(номер строки)...`, так объявлена память. После мы перемещаем 3 в регистр, отвечающий за количество байт, которое будет выведено, таким образом мы выводим именно символ `#` за ним номер строки и пробел.

Теперь перейдем к завершению основной программы.

#code(funcstr(lab4, "exit:"), "asm", [Завершаем основную программу])

В завершении программы выводим номер строки с максимальной суммой и саму сумму, с соответствующими поясняющими сообщениями, после чего вызываем систему для выхода.

#pagebreak()
== Компиляция

Название файла библеотеки вывода не изменилось, изменился файл, указанный в \$mod и файл библеотеки ввода. Вот, что необходимо ввести в терминал, для компиляции и сборки всех 3 файлов:

#code("mod=lab4/lab4 # Название ассемблерного файла без расширения
nasm -f elf -o $mod.o $mod.asm
nasm -f elf -o lab4/input.o lab4/input.asm
nasm -f elf -o lab2/output.o lab2/output.asm
ld -m elf_i386 -o $mod $mod.o lab4/input.o lab2/output.o
", "bash", [Команда в терминале])

== Отладка

Отладим всю программу на примере ввода одной строки.

#grid(
  columns:2,
  gutter:10pt,
  img(image("img/1.png", width: 88%), [Входим в ```asm getmas```]),
  img(image("img/2.png", width: 88%), [Выводим приглашение 1 строки])
)
#grid(
  columns:2,
  gutter:10pt,
  img(image("img/3.png", width: 88%), [Вводим 6 чисел]),
  img(image("img/4.png", width: 88%), [Значения введены])
)
#grid(
  columns:2,
  gutter:10pt,
  img(image("img/5.png", width: 88%), [Готовим регистры к\ циклу]),
  img(image("img/6.png", width: 88%), [Заходим в цикл и\ вызываем ```asm stoi```])
)
#grid(
  columns:2,
  gutter:10pt,
  img(image("img/7.png", width: 88%), [```asm stoi``` вернула 20]),
  img(image("img/8.png", width: 88%), [Записали число в память])
)
#grid(
  columns:2,
  gutter:10pt,
  img(image("img/9.png", width: 88%), [Число 30]),
  img(image("img/10.png", width: 88%), [Число 40])
)
#grid(
  columns:2,
  gutter:10pt,
  img(image("img/11.png", width: 88%), [Число 50]),
  img(image("img/12.png", width: 88%), [Число 60])
)
#grid(
  columns:2,
  gutter:10pt,
  img(image("img/13.png", width: 88%), [Число 70]),
  img(image("img/14.png", width: 88%), [Конец ```asm getmas```])
)
#grid(
  columns:2,
  gutter:10pt,
  img(image("img/15.png", width: 88%), [Вернулись в ```asm getarr```]),
  img(image("img/16.png", width: 88%), [Вызываем ```asm calcsum```])
)
#grid(
  columns:2,
  gutter:10pt,
  img(image("img/17.png", width: 88%), [Начало ```asm calcsum```]),
  img(image("img/18.png", width: 88%), [Берем 1 число])
)
#grid(
  columns:2,
  gutter:10pt,
  img(image("img/19.png", width: 88%), [Сравниваем с 0]),
  img(image("img/20.png", width: 88%), [Переходим к добавлнию])
)
#grid(
  columns:2,
  gutter:10pt,
  img(image("img/21.png", width: 88%), [1-ое число добавлено]),
  img(image("img/22.png", width: 88%), [2-ое число добавлено]),
)
#grid(
  columns:2,
  gutter:10pt,
  img(image("img/23.png", width: 88%), [3-ое число добавлено]),
  img(image("img/24.png", width: 88%), [4-ое число добавлено])
)
#grid(
  columns:2,
  gutter:10pt,
  img(image("img/25.png", width: 88%), [5-ое число добавлено]),
  img(image("img/26.png", width: 88%), [6-ое число добавлено])
)
#grid(
  columns:2,
  gutter:10pt,
  img(image("img/27.png", width: 88%), [Выходим из ```asm calcsum```]),
  img(image("img/28.png", width: 88%), [Проверяем больше ли получившееся сумма сохраненной])
)
#grid(
  columns:2,
  gutter:10pt,
  img(image("img/29.png", width: 88%), [Переходим к\ сохранению суммы]),
  img(image("img/30.png", width: 88%), [Сумма сохранена])
)
#grid(
  columns:2,
  gutter:10pt,
  img(image("img/31.png", width: 88%), [Индекс строки\ сохранен]),
  img(image("img/32.png", width: 88%), [Переходим к\ завершению ```asm getarr```])
)
#grid(
  columns:2,
  gutter:10pt,
  img(image("img/33.png", width: 88%), [Если меньше 4 строк обработано идем на следующую итерацию ]),
  img(image("img/34.png", width: 88%), [Начала ввода второй строки])
)

Далее программа повторит все те же действия для других значений и в результате выведет ответ и завершит работу. Это можно увидеть в тестах.

#pagebreak()
== Тестирование

#img(image("img/35.png", width: 60%), [Тест 1])
#img(image("img/36.png", width: 60%), [Тест 2])
#img(image("img/37.png", width: 60%), [Тест 3])
#img(image("img/38.png", width: 60%), [Тест 4])

== Вывод

В процессе выполения работы были изучены приемы моделирования обработки массивов и матриц в языке ассемблера.
#pagebreak()
== Контрольные вопросы

1. *Почему в ассемблере не определены понятия «массив», «матрица»?*
 Это связано с тем, что память имеет модель `flat`, то есть в ней все данные представлены последовательно (на одной прямой).

2. *Как в ассемблере моделируются массивы?*
 Например, ```asm A db 1, 2, 3, 4, 5, 6```, организуется массив, который в памяти будет представлен последовательно из 6 байтов.

3. *Поясните фрагмент последовательной адресации элементов массива? Почему при этом для хранения частей адреса используют регистры?*
 Используются регистры, для того чтобы увеличивать свое значение на один после каждой итерации цикла, таким образом обращаясь последовательно ко всем элементам массива.

4. *Как в памяти компьютера размещаются элементы матриц?*
 Последовательно.

5. *Чем моделирование матриц отличается от моделирования массивов? В каких случаях при выполнении операций для адресации матриц используется один регистр, а в каких – два?*
 Моделирование матриц от моделирования массивов отличается тем, что при работе с матрицами используются два цикла, один для определения строки матрицы, другой для определения столбца.




